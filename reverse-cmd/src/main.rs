use std::env;
use std::io::{Read, Write};
use std::net::{TcpListener, TcpStream};
use std::process::{Command, Stdio};
use std::thread;

const COLOR_BLUE: &str = "\x1b[38;2;29;78;216m";
const COLOR_GREEN: &str = "\x1b[38;2;40;167;69m";
const COLOR_DEFAULT: &str = "\x1b[0m";

fn recv(mut stream: &TcpStream) -> String {
    let mut data = Vec::new();
    loop {
        let mut buf = [0; 1024];
        match stream.read(&mut buf) {
            Ok(n) => {
                data.extend_from_slice(&buf[..n]);
                if data.contains(&b'\n') {
                    break;
                }
            }
            Err(_) => {
                break;
            }
        }
    }
    String::from_utf8_lossy(&data).trim().to_string()
}

fn handle_client(mut stream: TcpStream) {
    let mut current_dir = env::current_dir().unwrap();

    loop {
        let cmd = recv(&stream);
        if cmd.is_empty() {
            break;
        }

        let mut command_parts = cmd.trim().split_whitespace();
        let command = command_parts.next().unwrap_or("");
        let args = command_parts.collect::<Vec<_>>();

        match command {
            "cd" => {
                if let Some(new_dir) = args.get(0) {
                    if new_dir == &".." {
                        current_dir.pop();
                    } else {
                        current_dir.push(new_dir);
                    }
                    if let Err(err) = stream.write_all(b"Directory changed successfully\n") {
                        eprintln!("Error sending response to client: {}", err);
                        return;
                    }
                } else {
                    if let Err(err) = stream.write_all(b"Missing argument for cd\n") {
                        eprintln!("Error sending response to client: {}", err);
                        return;
                    }
                }
            }
            _ => {
                let output = match Command::new("bash")
                    .arg("-c")
                    .arg(&cmd)
                    .current_dir(&current_dir)
                    .stdout(Stdio::piped())
                    .stderr(Stdio::piped())
                    .output()
                {
                    Ok(output) => output,
                    Err(_) => {
                        if let Err(err) = stream.write_all(b"Error executing command\n") {
                            eprintln!("Error sending response to client: {}", err);
                            return;
                        }
                        continue;
                    }
                };

                if let Err(err) = stream.write_all(
                    format!("{}Response from server:{}\n", COLOR_BLUE, COLOR_DEFAULT).as_bytes(),
                ) {
                    eprintln!("Error sending response to client: {}", err);
                    return;
                }
                if let Err(err) = stream.write_all(&output.stdout) {
                    eprintln!("Error sending response to client: {}", err);
                    return;
                }
                if let Err(err) = stream.write_all(&output.stderr) {
                    eprintln!("Error sending response to client: {}", err);
                    return;
                }
            }
        }
    }
}

fn main() -> std::io::Result<()> {
    let listener = TcpListener::bind("127.0.0.1:5551")?;
    for stream in listener.incoming() {
        match stream {
            Ok(stream) => {
                println!(
                    "{}Connected with {}{}",
                    COLOR_GREEN,
                    stream.peer_addr().unwrap(),
                    COLOR_DEFAULT
                );

                thread::spawn(move || {
                    handle_client(stream);
                });
            }
            Err(err) => {
                eprintln!("Error accepting connection: {}", err);
            }
        }
    }
    Ok(())
}
